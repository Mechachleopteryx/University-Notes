<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CO351 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso-light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="../katex/katex.min.js" type="text/javascript"></script>
  <link rel="stylesheet" href="../katex/katex.min.css" />
  <script type="text/javascript">
  window.onload = function() {
    document.getElementsByClassName("status-banner")[0].style.display = "block";
    setTimeout(function() {
      renderMathElements(document.getElementsByClassName("math"));
      document.getElementsByClassName("status-banner")[0].style.display = "none";
    }, 50); // delay to allow status banner to show
  }

  function renderMathElements(mathElements) {
    var mathOptions = {
      macros: {
        "\\set": "\\left\\{ #1 \\right\\}",
        "\\tup": "\\left\\langle #1 \\right\\rangle",
        "\\abs": "\\left\\lvert #1 \\right\\rvert",
        "\\floor": "\\left\\lfloor #1 \\right\\rfloor",
        "\\ceil": "\\left\\lceil#1 \\right\\rceil",
        "\\mb": "\\mathbb{#1}",
        "\\rem": "\\operatorname{rem}",
        "\\ord": "\\operatorname{ord}",
        "\\sign": "\\operatorname{sign}",
        "\\imag": "\\bm{i}",
        "\\dee": "\\mathop{}\\!\\mathrm{d}",
        "\\lH": "\\overset{\\text{l'H}}{=}",
        "\\evalat": "\\left.\\left(#1\\right)\\right|",
        "\\sech": "\\operatorname{sech}",
        "\\spn": "\\operatorname{Span}",
        "\\proj": "\\operatorname{proj}",
        "\\prp": "\\operatorname{perp}",
        "\\refl": "\\operatorname{refl}",
        "\\magn": "\\left\\lVert #1 \\right\\rVert",
        "\\rank": "\\operatorname{rank}",
        "\\trace": "\\operatorname{trace}",
        "\\sys": "\\left[ #1 \\mid #2\\space \\right]",
        "\\range": "\\operatorname{Range}",
        "\\adj": "\\operatorname{adj}",
        "\\cof": "\\operatorname{cof}",
        "\\coord": "{\\left\\lbrack #1 \\right\\rbrack}_{#2}",
        "\\diag": "\\operatorname{diag}",
        "\\formlp": "\\operatorname{Form}(\\mathcal{L}^P)",
        "\\argmin": "\\operatorname{argmin}",
        "\\argmax": "\\operatorname{argmax}",
        "\\sgn": "\\operatorname{sgn}",

        // not yet available in KaTeX
        "\\bm": "\\mathbf", //wip: should be italic, but isn't
      },
    };
    for (var i=0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      try {
        katex.render(texText.data, mathElements[i], mathOptions);
      } catch (e) {
        console.error(e);
        console.log(mathElements[i]);
      }
    }
  }
  </script>
</head>
<body>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-68271407-1', 'auto');
    ga('send', 'pageview');

  </script>
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/resume.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="https://www.linkedin.com/in/uberi/" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:me@anthonyz.ca" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="https://twitter.com/anthony926535" class="contact">twitter</a></li>
    <span class="divider"></span>
    <li><a href="https://keybase.io/uberi" class="info">public key</a></li>
  </ul>
<h1 id="co351">CO351</h1>
<p>Network Flow Theory.</p>
<pre><code>Martin Pei
Section 001
Email: mpei@uwaterloo.ca
Office Hours: Mondays/Tuesdays 4pm-5pm in MC 6492
Mondays/Wednesdays/Fridays 1:30pm-2:20pm</code></pre>
<h1 id="section">8/9/17</h1>
<p>9 assignments, due on wednesdays, lowest assignment mark is dropped, submitted via Crowdmark. Assignment 0 is worth a bonus 1%.</p>
<p>Network theory deals with modelling problems using directed graphs, extending CS239. Network flow theory deals with flow problems over these directed graphs. A typical problem: given so-and-so network of roads (directed graph), each with different widths (cost of taking a road), how much traffic can we route from point A to B? Essentially, we're extending linear programming concepts from CO250 to directed graphs.</p>
<p>Real examples of networks: water pipes, electrical grid, and road networks.</p>
<p>Graph theory review: a <strong>graph</strong> is a pair of a set of vertices (arbitrary objects) and a set of edges, which are unordered pairs of vertices. The <strong>degree</strong> of a vertex is the number of edges incident to it, denoted <span class="math inline">d_G(v)</span>. A <strong>walk</strong> is a sequence of vertices in a graph where consecutive vertices are edges in the graph. A <strong>path</strong> is a walk with no repeated vertices or edges. A graph is <strong>connected</strong> if and only if there is a path between any two vertices. A <strong>cycle</strong> is a walk where the last vertex is the same as the first vertex. A <strong>cut induced by a set of vertices <span class="math inline">S</span></strong> is the set of edges with one end in <span class="math inline">S</span> and another end not in <span class="math inline">S</span>, denoted <span class="math inline">\delta(S)</span>. The size of a cut is denoted <span class="math inline">d(S)</span> or <span class="math inline">\abs{\delta(S)}</span>. A tree is a connected acyclic graph.</p>
<p>Theorem: there's an <span class="math inline">s, t</span>-path in <span class="math inline">G</span> if and only if for all <span class="math inline">X \subseteq V(G)</span> such that <span class="math inline">s \in X, t \notin X</span>, <span class="math inline">\delta(X) \ne \emptyset</span> - exactly when every subset of vertices including <span class="math inline">s</span> but not <span class="math inline">t</span> has a non-empty cut.</p>
<p>Proof:</p>
<blockquote>
<p>First we'll prove the forward direction. Assume an <span class="math inline">s, t</span>-path exists. Let <span class="math inline">v_0, \ldots, v_k</span> be one of those <span class="math inline">s, t</span>-paths, let <span class="math inline">X \subseteq V(G)</span> be an arbitrary subset of graph vertices such that <span class="math inline">s \in X, t \notin X</span>.<br />
Let <span class="math inline">i</span> be the smallest index in the <span class="math inline">s, t</span>-path such that <span class="math inline">v_i \notin X</span>. Since it's the smallest index, <span class="math inline">v_{i - 1}</span> must be in <span class="math inline">X</span>, so <span class="math inline">v_{i - 1} v_i \in \delta(X)</span>, so <span class="math inline">\delta(X)</span> is non-empty, as required.<br />
Now for the opposite direction. Assume no <span class="math inline">s, t</span>-path exists. Then <span class="math inline">s</span> and <span class="math inline">t</span> are in two different components <span class="math inline">A</span> and <span class="math inline">B</span>, since otherwise the path would exist.<br />
Clearly, the cut induced by <span class="math inline">A</span> must be empty, since if it isn't, then any vertex in the edges of the cut that weren't in <span class="math inline">A</span> should be in <span class="math inline">A</span>.</p>
</blockquote>
<p>Let <span class="math inline">T</span> be a tree. Then <span class="math inline">\abs{E(T)} = \abs{V(T)} - 1</span>. Also, a unique path exists between any two vertices, and adding any edge that doesn't already exist to <span class="math inline">T</span> will form exactly one cycle, Removing any edge from that resulting cycle gives us a tree again.</p>
<p>Directed graphs (digraphs) are very similar to graphs. A digraph <span class="math inline">D = \tup{N, A}</span> is a pair of a set of nodes (arbitrary objects) and a set of arcs, which are ordered pairs of nodes. Each node has an <strong>in-degree</strong> (number of arcs that point to it) denoted <span class="math inline">d(\overline v)</span> or <span class="math inline">d^-(v)</span>, and an <strong>out-degree</strong> (number of args that point from it) denoted <span class="math inline">d(v)</span> or <span class="math inline">d^+(v)</span>. A diwalk is a sequence of nodes such that consecutive nodes have arcs between them, a dipath is a directed walk with no duplicated nodes or arcs, and a dicycle is a dipath such that the first and last nodes are the same.</p>
<h1 id="section-1">11/9/17</h1>
<p>Directed graphs can have cycles of length 2, unlike undirected graphs. A directed graph is acyclic if there are no dicycles. We can also talk about cycles in a directed graph, which are simply the cycles if we ignore directions in the graph.</p>
<p>If every node of a digraph has out-degree of at least 1, the digraph must have a directed cycle. Proof: let <span class="math inline">v_0, \ldots, v_k</span> be the longest dipath in the digraph. Clearly, <span class="math inline">v_k</span> has out-degree at least 1, so it has an arc pointing to another node <span class="math inline">u</span>. Clearly, <span class="math inline">u</span> must be in the dipath, since if it wasn't then the path could be strictly longer, which isn't possible since the dipath is already the longest. So <span class="math inline">u</span> must be in the dipath, and this forms a directed cycle in the digraph.</p>
<p>Likewise for an undirected graphs, if every vertex has degree at least 2, there must be an undirected cycle. We can prove this in a very similar way.</p>
<p>A digraph is <strong>connected</strong> exactly when its corresponding undirected graph is connected - if every vertex in the underlying graph has a path to every other, ignoring direction. A digraph is <strong>strongly connected</strong> exactly when every node has a directed path to every other node.</p>
<p>For any subset of notes <span class="math inline">S \subseteq N</span>, the <strong>cut induced by <span class="math inline">S</span></strong> is the set <span class="math inline">\delta(S) = \set{xy \in A \middle| x \in S, y \notin S}</span> - the set of arcs that go outward from <span class="math inline">S</span>. There's also <span class="math inline">\delta(\overline S)</span>, which is the set of arcs that go inward toward <span class="math inline">S</span> (the cut induced by the complement).</p>
<p>Just like for an undirected graph, an <span class="math inline">s, t</span>-dipath exists if and only if every <span class="math inline">s, t</span>-cut is non-empty. The proof is very similar to the version for undirected graphs.</p>
<h2 id="transshipment-problem-tp">Transshipment problem (TP)</h2>
<p>Suppose we have a network consisting of a digraph, and some objects called <strong>supplies/goods</strong> present at various nodes (nodes are labelled with the net quantity demanded). We want to transport goods from where there's a negative net quantity demanded to where there's a positive net quantity demanded. The quantity we transport along the arcs is the flow. In other words, <strong>a flow is a weighting for each arc in a digraph</strong>, representing how much of a quantity we're transporting along that arc.</p>
<p>The <strong>inflow of a node</strong> is the sum of the weights of the arcs going into the node. The <strong>outflow of a node</strong> the sum of the weights of the arcs leaving the node. Inflow minus outflow is the weight of the vertex - the net quantity demanded.</p>
<p>There are also <strong>costs</strong> associated with letting goods flow through an arc. A <strong>cost</strong> is a edge weighting, just like a flow, but the weight of an edge represents the cost of transporting one unit of a good through that arc.</p>
<p>The goal of the problem is to find a flow such that the net quantity demanded becomes non-positive, such that we minimize the cost of that flow.</p>
<p>New notation: <span class="math inline">\vec o \in \mb{R}^S</span>, where <span class="math inline">S</span> is a set, means that <span class="math inline">o</span> is a vector with <span class="math inline">\magn{S}</span> elements, each one representing an element <span class="math inline">s</span> of <span class="math inline">S</span>. Additionally, we can write the element corresponding to <span class="math inline">s</span> as <span class="math inline">o_s</span>.</p>
<p>Formally: suppose we have a digraph <span class="math inline">D = \tup{N, A}</span>, a node weighting <span class="math inline">\vec b \in \mb{R}^N</span> (the net quantity demanded of the good at each node in <span class="math inline">N</span>), and an arc weighting <span class="math inline">\vec w \in \mb{R}^A</span> (the cost of transporting a unit of the good through each arc in <span class="math inline">A</span>). A <strong>flow</strong> is an arc weighting <span class="math inline">\vec x \in \mb{R}^A</span> such that <span class="math inline">\vec x \ge \vec 0</span> and <span class="math inline">\sum_{iv \in A} x_{iv} - \sum_{vj \in A} x_{vj} = b_v</span> for all <span class="math inline">v \in N</span> (total inflow minus total outflow is equal to <span class="math inline">b_v</span> for any <span class="math inline">v \in N</span>). The problem is to minimize <span class="math inline">\sum_{ij \in A} w_{ij} x_{ij}</span>.</p>
<h1 id="section-2">13/9/17</h1>
<p>Intuitively, a flow problem on a digraph tries to move positive quantities of goods along arcs from nodes that are negative to nodes that are positive.</p>
<p>If <span class="math inline">b_v</span> is positive for a node <span class="math inline">v</span>, then <span class="math inline">v</span> is a supply node. If it's negative, <span class="math inline">v</span> is a demand node.</p>
<p>New notation: if <span class="math inline">N \subseteq S</span>, then <span class="math inline">o(N) = \sum_{v \in N} o_v</span>. In other words, if we call a vector like a function with a set of indices, we get back the sum of the elements at those indices.</p>
<p>Therefore, <span class="math inline">\sum_{iv \in A} x_{iv} - \sum_{vj \in A} x_{vj} = b_v</span>$ is equivalent to <span class="math inline">x(\delta(\overline v)) - x(\delta(v)) = b_v</span> for all <span class="math inline">v \in N</span>.</p>
<p>Additional assumptions for network flow problems in this course:</p>
<ul>
<li>The digraph <span class="math inline">D</span> is connected.</li>
<li>The weights are all positive - <span class="math inline">\vec w \ge \vec 0</span>.</li>
<li>The total quantity demanded is equal to the total quantity supplied (sum of net demands in 0) - <span class="math inline">b(N) = 0</span>.</li>
</ul>
<p>The transshipment problem can be solved simply using linear programming. The general form of the LP is: &quot;minimize <span class="math inline">\sum_{ij \in A} w_{ij} x_{ij}</span> subject to <span class="math inline">\sum_{iv \in A} x_{iv} - \sum_{vj \in A} x_{vj} = b_v</span> for all <span class="math inline">v \in N</span>, <span class="math inline">\vec x \ge \vec 0</span>&quot; (the values of <span class="math inline">\vec w</span> and <span class="math inline">\vec b</span> are fixed). In other words, <strong>we're minimizing the total cost of performing the shipments such that we still manage to make inflow minus outflow equal to the net quantity demanded for each individual node</strong>.</p>
<p>In matrix form, the columns are indexed by arcs, and the rows are indexed by nodes. At a given row <span class="math inline">a</span> and column <span class="math inline">ab</span> within the matrix, we put a 0 when there's no such arc, 1 if the digraph contains the arc <span class="math inline">ba</span>, and -1 if the digraph contains the arc <span class="math inline">ab</span>.</p>
<p>Formally, an <strong>incidence matrix</strong> for a digraph <span class="math inline">D = \tup{N, A}</span> is an <span class="math inline">\abs{N}</span> by <span class="math inline">\abs{A}</span> matrix <span class="math inline">M</span> where <span class="math inline">M_{v, ij} = \begin{cases} -1 &amp;\text{if } v = i \\ 1 &amp;\text{if } v = j \\ 0 &amp;\text{otherwise} \end{cases}</span>. As it turns out, the matrix form of the LP for the transshipment problem will always have a coefficients matrix that is the incidence matrix of the digraph, under the assumptions we make for this course.</p>
<p>Therefore, we can write the LP more simply as &quot;minimize <span class="math inline">\vec w \cdot \vec x</span> subject to <span class="math inline">M \vec x = \vec b</span>, <span class="math inline">\vec x \ge \vec 0</span>&quot;, where <span class="math inline">M</span> is the incidence matrix for the digraph, <span class="math inline">\vec w</span> is the costs for each arc, <span class="math inline">\vec b</span> is the net quantity demanded in each vertex, and <span class="math inline">\vec x</span> is the amount of goods to send along each edge.</p>
<p>Interestingly, since in an incidence matrix, every column of <span class="math inline">M</span> has exactly one 1 and one -1, or is all 0. Therefore, the sum of all the rows in the matrix gives <span class="math inline">\vec 0</span>. If we sum the <span class="math inline">A \vec x = \vec b</span>, we get <span class="math inline">b(N) = 0</span> - our assumption that the total net quantity demanded is 0.</p>
<p>Consider now the dual for the LP: &quot;minimize <span class="math inline">\vec b \cdot \vec y</span> subject to <span class="math inline">M^T \le \vec c</span> for all <span class="math inline">ij \in A</span>, <span class="math inline">\vec y</span> free&quot;, where <span class="math inline">M</span> is the incidence matrix for the digraph. We can then use complementary slackness to show that the LP is optimal.</p>
<h1 id="section-3">15/9/17</h1>
<p>Assignment 1 is out, due on Wednesday.</p>
<p>New notation: <span class="math inline">M_a</span> is the column in <span class="math inline">M</span> corresponding to the arc <span class="math inline">a</span>.</p>
<p>New notation: <span class="math inline">\overtilde M</span> is <span class="math inline">M</span> with the last row removed.</p>
<p>Summary of transshipment problem (TP): minimize <span class="math inline">\vec w^T \vec x</span> subject to <span class="math inline">M \vec x = \vec b</span> and <span class="math inline">\vec x \ge \vec 0</span>. Here, <span class="math inline">\vec w</span> is the costs, <span class="math inline">\vec b</span> is the demands, and <span class="math inline">M</span> is the indcidence matrix. The <span class="math inline">M \vec x = \vec b</span> is called the <strong>flow constraint</strong>, while the <span class="math inline">\vec x \ge \vec 0</span> is the <strong>non-negativity constraint</strong>.</p>
<p>To start solving a TP instance with Simplex, we need to find a feasible basis. However, note that the rows of the incidence matrix <span class="math inline">M</span> are not linearly independent, since when you sum up all the rows, you get <span class="math inline">\vec 0</span> - the rank of the <span class="math inline">n</span> by <span class="math inline">m</span> incidence matrix is <span class="math inline">n - 1</span>. ;wip: why can't it be less than <span class="math inline">n - 1</span>? add proof</p>
<p>To get around this, we ignore one row, so we pretend the matrix is <span class="math inline">n - 1</span> by <span class="math inline">m</span>, and pick <span class="math inline">n - 1</span> columns for a basis instead. We usually can do this by inspection, or the auxilary problem method.</p>
<p>In fact, the columns of <span class="math inline">M</span> that correspond to the edges of any undirected cycle are linearly dependent, and those that do not are linearly independent. Proof: for any undirected arc <span class="math inline">v_1, \ldots, v_k, v_1</span> in a digraph, <span class="math inline">v_i v_{i + 1}</span> is a forward arc, whereas <span class="math inline">v_{i + 1} v_i</span> is a backward/reverse arc. Let <span class="math inline">F</span> be the set of forward arcs in the undirected cycle, and <span class="math inline">R</span> the reverse arcs. Clearly, <span class="math inline">\sum_{a \in F} M_a - \sum_{a \in R} M_a</span> has the same sum as if the undirected cycle was a dicycle instead. Clearly, the sum of the arcs in a dicycle is 0, since for the dicycle each row will have exactly one -1 and one 1 entry (one incoming arc and one outgoing arc) <span class="math inline">\sum_{a \in F} M_a - \sum_{a \in R} M_a = 0</span>. We've now found <span class="math inline">k</span> columns that are linearly dependent, since they sum to 0.</p>
<p>Likewise, a set of linearly dependent columns must contain an undirected cycle (proof left as exercise). So <strong>there exists a set of linearly dependent columns if and only if the arcs corresponding to the columns in that set form an undirected cycle</strong>.</p>
<p>So to find a basis (ignoring one row) of <span class="math inline">\overtilde M</span>, we need to find a set of <span class="math inline">n - 1</span> linearly independent arcs - so by the above proof, a set of <span class="math inline">n - 1</span> arcs that don't have any cycles. From graph theory, this must be a spanning tree by definition, since it has no cycles and contains <span class="math inline">n</span> vertices - <strong>a set of columns of an incidence matrix <span class="math inline">M</span> is a basis for <span class="math inline">M</span> if and only if the arcs corresponding to those columns forms a spanning tree of the digraph</strong>. Note that spanning trees ignore arc direction, as if we're working on an undirected graph.</p>
<p>To find a basic solution corresponding to some spanning tree, we can start from the leaves (vertices in the spanning tree of degree 1) and work our way up to the root - a leaf node of value -10 must have 10 flow coming out of it, since it must end up with 0 value in the end, for example. This isn't necessarily a basic feasible solution, because it might not satisfy the non-negativity constraint - some of the flow directions might be different from the arc directions, like if we have a negative valued node and in the spanning tree, it's incident to an inward pointing arc. If we get an infeasible solution, we can just keep trying other spanning trees until we find a feasible one.</p>
<h1 id="section-4">18/9/17</h1>
<p>Review of simplex method. In the simplex method, at all times we maintain a basic feasible solution for the LP, and a solution for the dual that satisfies all constraints (except the non-negativity constraints), and the complementary slackness conditions. Each step fixes some of the non-negativity constraints, so eventually both dual and primal solutions are satisfied, and by the complementary slackness theorem, both solutions must be optimal.</p>
<p>Recall the transshipment problem LP: &quot;minimize <span class="math inline">\vec w \cdot \vec x</span> subject to <span class="math inline">M \vec x = \vec b</span> and <span class="math inline">\vec x \ge \vec 0</span>&quot;, as well as its dual, &quot;maximize <span class="math inline">\vec b \cdot \vec y</span> subject to <span class="math inline">-y_a + y_b \le w_{ab}</span> for all <span class="math inline">ab \in A</span> and <span class="math inline">\vec y</span> free&quot;. The vector <span class="math inline">\vec y</span> is knows is the <strong>node potential</strong>.</p>
<p>To start solving this using simplex, we start by adding a slack variable to each dual inequality: &quot;maximize <span class="math inline">\vec b \cdot \vec y</span> subject to <span class="math inline">-y_a + y_b + \overline{w}_{ab} = w_{ab}</span> for all <span class="math inline">ab \in A</span> and <span class="math inline">\vec y</span> free and <span class="math inline">\vec{\overline{w}} \ge \vec 0</span>&quot;. Here, the <span class="math inline">\overline{w}_{ab} = w_{ab} + y_i - y_j</span> is called the <strong>reduced cost</strong> of the arc <span class="math inline">ab</span>.</p>
<p>A node potential <span class="math inline">\vec y</span> is a <strong>feasible node potential</strong> if and only if the non-negativity constraints are satisfied for <span class="math inline">\overline{w}_{ab}</span> for all b A$ - when all the slack variables are non-negative. By complementary slackness, if <span class="math inline">x_{ab} &gt; 0</span>, then <span class="math inline">\overline{w}_{ab} = 0</span> in the dual LP. $a When we're using the simplex method, we start off with a basic feasible solution. This gives us a spanning tree over the digraph, and we then choose an entering arc and a leaving arc. Adding the entering arc forms a cycle, and removing the leaving arc breaks it again.</p>
<h1 id="section-5">20/9/17</h1>
<p>;wip: missed, but was about network simplex algo</p>
<h1 id="section-6">22/9/17</h1>
<p>Finishing off the network simplex example we went through last time.</p>
<p>By the fundamental theorem of linear programming, a linear program is always unbounded, infeasible, or has an optimal solution.</p>
<p>What do the dual potentials <span class="math inline">\vec y</span> for nodes mean? Well, we might think of each value of <span class="math inline">\vec y</span> as the relative price of buying the good at that node - if <span class="math inline">\vec y_a = 0</span> and there's an arc of cost 30 to node <span class="math inline">b</span>, then <span class="math inline">\vec y_b = 30</span>. Likewise, if there's then an arc of cost 50 from <span class="math inline">b</span> to <span class="math inline">c</span> in our spanning tree, then <span class="math inline">\vec y_c = 80</span>.</p>
<p>Note that we can add any constant to all of the elements of <span class="math inline">\vec y</span> without violating any of the constraints - this represents adjusting the base price of the product. This is because in the reduced cost formula, the constant added to <span class="math inline">y_u</span> and <span class="math inline">y_v</span> will cancel each other out.</p>
<p>What do the reduced costs <span class="math inline">\overline w_{uv} = w_{uv} + y_u - y_v</span> for arcs mean? Well, we might think of <span class="math inline">y_v</span> as the buying/selling price at node <span class="math inline">v</span>, so the <span class="math inline">\overline w_{ab}</span> could be thought of as the cost of buying a unit of a good at <span class="math inline">u</span>, transporting it to <span class="math inline">v</span>, and then selling it at <span class="math inline">v</span>.</p>
<p>If the reduced cost of an arc is negative, we would make a profit by transporting goods along the arc - we want to include that arc in our spanning tree. If the reduced costs of a node is 0, then the prices are fair, so we are ambivalent about including the arc in the tree. If the reduced cost is positive, we would lose money by transporting the goods, so we want to exclude the arc from our spanning tree.</p>
<p>Note that when we're going network simplex, the dual will be infeasible until the very end, because we allow the reduced costs to be negative and keep changing things until they're not.</p>
<p>In the normal simplex algorithm, we discover that the LP is unbounded when we pick an entering variable, but we can't find a leaving variable - the variables' columns in the tableau are all non-positive, which means we can add it as many times as we want, without making the constraints infeasible.</p>
<p>Analogously, a transshipment problem is unbounded when we cannot pick a leaving arc - if and only if we create a cycle by adding our entering arc such that all the arcs in the cycle are forward arcs (a <strong>negative cycle</strong>). This causes all of the reduced costs to be negative. Given a cycle <span class="math inline">v_0, \ldots, v_n</span>, <span class="math inline">y_{v_k} = y_{v_0} + w_{v_0 v_1} + \ldots w_{v_{k - 1} v_k}</span>, and the reduced cost of any arc <span class="math inline">v_k v_{k + 1}</span> is then <span class="math inline">\overline w_{uv} = w_{v_0 v_1} + \ldots + w_{v_{k - 1} v_k}</span>. Since <span class="math inline">v_k v_{k + 1}</span> is entering, <span class="math inline">\overline w_{v_k v_{k + 1}}</span> must be negative, so the cycle is a negative dicycle.</p>
<p>Intuitively, we can think of this as being a case where we could just keep shipping goods around and around the cycle to make more and more profit, with no uppoer bound on the amount of profit. In other words, we can send an arbitrarily large flow along this negative dicycle at an arbitrarily low overall cost, which makes it unbounded.</p>
<h1 id="section-7">25/9/17</h1>
<p>As we looked at earlier, a feasible transshipment problem is unbounded if and only if there is a negative dicycle. Proof:</p>
<blockquote>
<p>Let <span class="math inline">x^*</span> be a feasible solution for the transshipment problem (this must exist since the problem is known to be feasible).<br />
See assignment 3 for the forward direction. We will only prove the reverse direction here.<br />
Assume there is a negative dicycle <span class="math inline">C</span>. Let <span class="math inline">x_{ij}^c = \begin{cases} 1 &amp;\text{if } ij \in C \\ 0 &amp;\text{otherwise} \end{cases}</span>.<br />
Clearly, <span class="math inline">x^c(\delta(\overline v)) = x^c(\delta(v))</span>, since <span class="math inline">C</span> is a directed cycle.<br />
So <span class="math inline">x^* + tx^c</span> is also a feasible solution for any <span class="math inline">t \ge 0</span>. Verify feasibility for main constraints: for each <span class="math inline">v</span>, <span class="math inline">(x^* + x^c)(\delta(\overline v)) - (x^* + x^c)(\delta(v)) = x^*(\delta(\overline v)) - x^c(\delta(v)) + t(v^c(\delta(\overline v)) - x^c(\delta(v))) = b_v + t \times 0 = b_b</span>.<br />
Since <span class="math inline">x^* \ge \vec 0</span>, <span class="math inline">t \ge 0</span>, and <span class="math inline">x^c \ge \vec 0</span>, thenon-negativity constraints <span class="math inline">x^* + t x^c \ge 0</span> are satisfied.<br />
Clearly, <span class="math inline">\vec w \cdot x^* + t w(C)</span>, the objective function value, goes to infinity as <span class="math inline">t</span> goes to infinity since <span class="math inline">w(C) &lt; 0</span>, so the LP is unbounded.</p>
</blockquote>
<p>Suppose we have a set of nodes <span class="math inline">S \subseteq N</span>, and <span class="math inline">\vec xx</span> is a solution that satisfies the flow constraints. Then <span class="math inline">\vec b(S) = \vec x(\delta(\overline S)) - \vec x(\delta(S))</span>. In other words, when we have a bunch of nodes, the net inflow to all of those is the sum of all the net inflows for those nodes. Proof:</p>
<blockquote>
<p>Since <span class="math inline">\vec x</span> satisfies the flow constraints, <span class="math inline">\vec x(\delta(\overline v)) - \vec x(\delta(v))</span> for all <span class="math inline">v \in N</span>. Then <span class="math inline">\vec b(S) = \sum_{v \in S} \vec x(\delta(\overline v)) - \sum_{v \in S} \vec x(\delta(v))</span>.<br />
If an arc <span class="math inline">ij</span> has <span class="math inline">i \in S, j \in S</span>, then it contributes <span class="math inline">x_{ij}</span> to both <span class="math inline">i</span> and <span class="math inline">j</span>, so they cancel out. If <span class="math inline">i \in S, j \notin S</span>, <span class="math inline">ij</span> contributes <span class="math inline">x_{ij}</span> to <span class="math inline">\sum_{v \in S} \vec x(\delta(v))</span>. If <span class="math inline">i \notin S, j \in S</span>, <span class="math inline">ij</span> contributes <span class="math inline">x_{ij}</span> to <span class="math inline">\sum_{v \in S} \vec x(\delta(\overline v))</span>.<br />
So <span class="math inline">\sum_{v \in S} \vec x(\delta(\overline v)) - \sum_{v \in S} \vec x(\delta(v)) = \vec x(\delta(\overline S)) - \vec x(\delta(S)) = \vec b(S)</span>, as required.</p>
</blockquote>
<p>When we remove a leaving arc, we're left with two trees. We then choose an entering arc to fix the tree by connecting a node from one tree to a node of the other, in the reverse direction of the removed arc. An infeasible network occurs when the net inflow to a subset of nodes is positive, but no arc goes into it.</p>
<h1 id="section-8">27/9/17</h1>
<p>In other words, a TP is infeasible if and only if there exists <span class="math inline">S \subseteq N</span> such that <span class="math inline">\vec b(S) &lt; 0</span> and <span class="math inline">\delta(S) = \emptyset</span>. Proof:</p>
<blockquote>
<p>Assume there exists <span class="math inline">S \subseteq N</span> such that <span class="math inline">\vec b(S) &lt; 0</span> and <span class="math inline">\delta(S) = \emptyset</span>. Suppose there exists a feasible solution <span class="math inline">\vec x</span>.<br />
From last class, we know that <span class="math inline">\vec b(S) = \vec x(\delta(\overline S)) - \vec x(\delta(S))</span> (the net quantity demanded in a set of nodes is the sum of all the net quantity demanded in the nodes).<br />
Clearly, <span class="math inline">\vec x(\delta(S)) = 0</span> since <span class="math inline">\delta(S) = \emptyset</span>. Clearly, <span class="math inline">\vec x(\delta(\overline S)) \ge 0</span> since it consists entirely of incoming arcs, which means <span class="math inline">\vec b(S) \ge 0</span>, a contradiction.<br />
So there cannot exist a feasible solution <span class="math inline">\vec x</span>. <span class="math inline">S</span> acts as a <strong>certificiate</strong> that the TP is infeasible.</p>
</blockquote>
<p>For linear programs, we can use an <strong>auxilary LP</strong> to find a feasible solution. Consider an LP in SEF &quot;max <span class="math inline">\vec c \cdot \vec x</span> subject to <span class="math inline">A \vec x = \vec b</span> and <span class="math inline">\vec x \ge 0</span>&quot;. We invert constraints whose right hand side is negative, change the equalities to inequalities, add slack variables accordingly, and then try to minimize the slack variables, to get &quot;min <span class="math inline">\vec 1 \cdot \vec s</span> subject to <span class="math inline">A \vec x + \vec s = \vec b</span> and <span class="math inline">\vec x \ge 0</span> and <span class="math inline">\vec s \ge 0</span>&quot;. The original LP must then be feasible if and only if this auxilary LP's objective function value ends up being 0.</p>
<p>We can apply this to TPs as well, using a very similar technique. Suppose we have a TP &quot;max <span class="math inline">\vec c \cdot \vec x</span> subject to <span class="math inline">M \vec x = \vec b</span> and <span class="math inline">\vec x \ge 0</span>&quot;. For each constraint <span class="math inline">i</span>, we add a slack variable <span class="math inline">s_i</span> if <span class="math inline">b_i &gt; 0</span>, and subtract a slack variable <span class="math inline">s_i</span> if <span class="math inline">b_i &lt; 0</span> (no slack variable if <span class="math inline">b_i = 0</span>). We then add a redundant constraint <span class="math inline">\sum_{i: b_i &lt; 0} s_i - \sum_{i: b_i \ge 0} = 0</span>. The new TP then tries to minimize the sum of all the slack variables.</p>
<p>Intuitively, we added a node with net quantity demanded 0 (the redundant constraint) that connects to nodes with positive quantity demanded, and connects from nodes with negative quantity supplied, all with weight 1. We're easily able to find a feasible basis because we can send all our supply to that redundant node, and distribute it from there to all the places it's demanded, and once we have a feasible basis, we can optimize to avoid those arcs connecting to the redundant node using TP Simplex.</p>
<h1 id="section-9">29/9/17</h1>
<p>Exam questions will be similar to assignment questions.</p>
<p>So given a TP with network <span class="math inline">D</span> and demands <span class="math inline">b</span>, we get the auxilary TP by adding a new node <span class="math inline">v</span> with demand 0, arcs <span class="math inline">pv</span> for all <span class="math inline">p \in N</span> such that <span class="math inline">b_p &lt; 0</span>, arcs <span class="math inline">vp</span> for all <span class="math inline">p \in N</span> such that <span class="math inline">b_p &gt; 0</span>, to get the new network <span class="math inline">D&#39;</span>. Let arcs have cost 0 in <span class="math inline">D&#39;</span> they're from <span class="math inline">D</span>, and 1 when they're from arcs we just added. Then <span class="math inline">D</span> has a feasible solution if and only if the auxilary TP <span class="math inline">D&#39;</span> has an optimal solution with objective function value 0. Proof:</p>
<blockquote>
<p>Assume there is a feasible flow for <span class="math inline">D</span>. Then, if we copy the flow into <span class="math inline">D&#39;</span> and set the rest of the flow values to 0, we get a feasible solution for <span class="math inline">D&#39;</span>, and it has objective value 0 since it doesn't use any of the new arcs - this is an optimal solution with objective function value 0.<br />
Assume there's an optimal solution with objective function value 0 in <span class="math inline">D&#39;</span>. Then there is a feasible flow for <span class="math inline">D&#39;</span> such that all arcs that we added with cost 1 have no flow through them. The flow on the remaining arcs (the arcs that are also in <span class="math inline">D</span>) must then form a feasible flow for <span class="math inline">D</span>.<br />
Additionally, we can ensure this is a feasible tree flow because the TP Simplex method always finds an optimal spanning tree.<br />
Now for the other direction. Assume <span class="math inline">D</span> is infeasible. Then <span class="math inline">D&#39;</span> must have an optimal tree flow <span class="math inline">T</span> that contains the artificial node <span class="math inline">v</span> we added.<br />
Consider this tree flow with that new node <span class="math inline">v</span> as the root, particularly the artificial arcs (arcs we added to connect <span class="math inline">v</span> with other nodes).<br />
Let <span class="math inline">N^-</span> be the set of nodes that are adjacent to <span class="math inline">v</span> within <span class="math inline">T</span> having negative net quantity demanded, and <span class="math inline">N^+</span> be those with positive net quantity demanded.<br />
Clearly, each node <span class="math inline">u</span> in <span class="math inline">N^-</span> or <span class="math inline">N^+</span> is the root of its own subtree in <span class="math inline">T</span>. Let <span class="math inline">T_u</span> be that subtree.<br />
Let <span class="math inline">y</span> be a feasible potential where <span class="math inline">y_v = 0</span>. Each node <span class="math inline">u \in N^-</span> is incident with an arc <span class="math inline">uv</span> with cost 1, so <span class="math inline">y_u = -1</span>. Likewise for each <span class="math inline">u \in N^+</span>, so <span class="math inline">y_u = 1</span>.<br />
Since all arcs in <span class="math inline">D&#39;</span> that are also in <span class="math inline">D</span> have cost 0, any node <span class="math inline">T_u</span> where <span class="math inline">u \in N^-</span>has potential -1, and any node <span class="math inline">T_u</span> where <span class="math inline">u \in N^+</span> has potential 1.<br />
Let <span class="math inline">S = \set{w \in T_u : u \in N^-}</span> - all nodes from all subtrees rooted in <span class="math inline">N^-</span>.<br />
Clearly, all arcs from <span class="math inline">S</span> to <span class="math inline">v</span> have positive positive flow, so <span class="math inline">\vec x(\delta(S)) &gt; 0</span> and <span class="math inline">x(\delta(\overline S)) = 0</span> (there's no arcs <span class="math inline">\overline S</span> in <span class="math inline">T</span> since it's a tree).<br />
By the previous lemma, <span class="math inline">\vec b(S) &lt; 0</span>. If there exists an arc <span class="math inline">pq \in \delta(S)</span> in <span class="math inline">D</span> where <span class="math inline">p \in S, q \notin S</span>, then <span class="math inline">y_p = -1, w_{pq} = 0, y_q = 1</span>, so <span class="math inline">\overline w_{pq} = -1</span>.<br />
So <span class="math inline">y</span> is not a feasible potential, a contradiction, so <span class="math inline">\delta(S) = \emptyset</span>, as required. ;wip: where's the contradiction</p>
</blockquote>
<h2 id="minimum-cost-flow-problem-mcf">Minimum Cost Flow Problem (MCF)</h2>
<p>This is a generalization of the transshipment problem, where arcs have a maximum capacity - the flow on a given arc might be limited by the arc's capacity.</p>
<p>When we draw the networks, we now label nodes with net quantity demanded, and arcs with pairs containing arc costs and arc capacity.</p>
<p>We can still formulate this as an LP: given a digraph <span class="math inline">D = \tup{N, A}</span>, node demands <span class="math inline">\vec b \in \mb{R}^N</span>, arc costs <span class="math inline">w \in \mb{R}^A</span>, arc capacities <span class="math inline">c \in \mb{R}^A</span>, we have the LP &quot;minimize <span class="math inline">\vec w \cdot \vec x</span> subject to <span class="math inline">\vec x(\delta(\overline v)) - \vec x(\delta(v)) = b_v</span> for all <span class="math inline">v \in N</span> and <span class="math inline">x_{uv} \le c_{uv}</span> for all <span class="math inline">uv \in A</span> and <span class="math inline">\vec x \ge \vec 0</span>&quot;.</p>
<p>We usually write this as &quot;minimize <span class="math inline">\vec w \cdot \vec x</span> subject to <span class="math inline">\vec x(\delta(\overline v)) - \vec x(\delta(v)) = b_v</span> for all <span class="math inline">v \in N</span> and <span class="math inline">x_{uv} + s_{uv} \le c_{uv}</span> for all <span class="math inline">uv \in A</span> and <span class="math inline">\vec x \ge \vec 0</span> and <span class="math inline">\vec s \ge \vec 0</span>&quot;, where <span class="math inline">s_{uv}</span> are slack variables.</p>
<p>Consider now the dual of this LP. For the &quot;<span class="math inline">x_{uv} \le c_{uv}</span> for all <span class="math inline">uv \in A</span>&quot; constraint, we have to multiply by -1 to get &quot;<span class="math inline">-x_{uv} \ge -c_{uv}</span> for all <span class="math inline">uv \in A</span>&quot;. We'll represent the dual variables as two vectors now, <span class="math inline">\vec y</span> for the flow constraints, and <span class="math inline">\vec z</span> for the capacity constraints. We now have the dual &quot;maximize <span class="math inline">\vec b \cdot \vec y - \vec c \cdot \vec z</span> subject to <span class="math inline">-y_u + y_v - z \le w_{uv}</span> for all <span class="math inline">uv \in A</span> and <span class="math inline">\vec y, \vec z \ge 0</span>&quot;.</p>
<h1 id="section-10">2/10/17</h1>
<p>For TP instances, basic solutions were spanning trees. What does a basic solution look like for the MCFP?</p>
<p>There are <span class="math inline">2m</span> variables - two for each arc. The rank of the matrix is <span class="math inline">m + n - 1</span>, since the incidence matrix has rank <span class="math inline">n - 1</span> and the <span class="math inline">m</span> capacity constraints are linearly independent. Therefore, a basic solution must have <span class="math inline">m + n - 1</span> basic variables, and all other variables must be 0.</p>
<p>For each <span class="math inline">uv \in A</span>, at least one of <span class="math inline">x_{uv}</span> or <span class="math inline">s_{uv}</span> is basic - if they weren't, then <span class="math inline">x_{uv} + s_{uv} = 0 \ne c_{uv}</span>, which is a contradiction. If <span class="math inline">x_{uv}</span> is basic but <span class="math inline">s_{uv}</span> is not, then <span class="math inline">x_{uv} = c_{uv}</span>. If <span class="math inline">s_{uv}</span> is basic but <span class="math inline">x_{uv}</span> is not, then <span class="math inline">x_{uv} = 0</span>. Otherwise, <span class="math inline">0 \le x_{uv} \le c_{uv}</span>.</p>
<p>Let <span class="math inline">k</span> be the number of arcs <span class="math inline">uv</span> in the basic solution such that both <span class="math inline">x_{uv}</span> and <span class="math inline">s_{uv}</span> are basic solutions. Then there must be <span class="math inline">m - k</span> arcs that appear exactly once in a basic solution, while <span class="math inline">k</span> arcs appear twice each. So <span class="math inline">m + n - 1 = 2k + (m - k)</span>, so <span class="math inline">k = n - 1</span>.</p>
<p>If we have a set of arcs containing a cycle and both variables for arcs in that set are basic, then the columns of the <span class="math inline">s_{uv}</span> values cancel out <span class="math inline">x_{uv}</span> in the bottom rows in the LP's matrix form (for the capacity constraints). The remaining, uncancelled-out values of <span class="math inline">x_{uv}</span> form the incidence matrix for the graph, which is linearly dependent. The set of arcs where both variables are basic for each arc in the set form a spanning tree. All non-tree arcs must then have flow at 0 or at capacity.</p>
<p>Consider now the dual of the MCFP: &quot;maximize <span class="math inline">\vec b \cdot \vec y - \vec c \cdot \vec z</span> subject to <span class="math inline">-y_u + y_v - z_{uv} \le w_{uv}</span> and <span class="math inline">\vec z \ge \vec 0</span>&quot;.</p>
<p>Complementary slackness conditions:</p>
<ol type="1">
<li>One or more of <span class="math inline">x_{uv} = c_{uv}</span> or <span class="math inline">z_{uv} = 0</span> is true.</li>
<li>One or more of <span class="math inline">x_{uv} = 0</span> or <span class="math inline">-y_u + y_v - z_{uv} = w_{uv}</span> is true.</li>
</ol>
<p>Each <span class="math inline">z_{uv}</span> is only present in two constraints: <span class="math inline">z_{uv} \ge 0</span> and <span class="math inline">-y_u + y_v - z_{uv} \le w_{uv}</span> is true. Since the reduced cost is defined as <span class="math inline">\overline w_{uv} = y_u + w_{uv} - y_v</span>, we have <span class="math inline">\overline w_{uv} \ge -z_{uv}</span> or <span class="math inline">z_{uv} \ge -\overline w_{uv}</span>.</p>
<p>In the objective function, we maximize <span class="math inline">-c_{uv} z_{uv}</span>, which means we want to minimize <span class="math inline">z_{uv}</span> - <span class="math inline">z_{uv} = \max\set{0, -\overline w_{uv}}</span>.</p>
<p>Clearly, the first complementary slackness condition is equivalent to: If <span class="math inline">z_{uv} &gt; 0</span>, then <span class="math inline">x_{uv} = c_{uv}</span>. <span class="math inline">z_{uv} &gt; 0</span> if and only if <span class="math inline">\overline w_{uv} &lt; 0</span>.</p>
<p>Clearly, the second complementary slackness condition is equivalent to: If <span class="math inline">\overline w_{uv} &lt; 0</span>, then <span class="math inline">x_{uv} = c_{uv}</span>.</p>
<h1 id="section-11">4/10/17</h1>
<p>;wip: missed due to interviews</p>
<h1 id="section-12">6/10/17</h1>
<p>;wip: missed due to interviews</p>
<h1 id="section-13">13/10/17</h1>
<p>;wip: missed due to interviews</p>
<h1 id="section-14">16/10/17</h1>
<p>;wip: missed due to interviews</p>
<h1 id="section-15">18/10/17</h1>
<p>;wip: missed due to interviews</p>
<h1 id="section-16">20/10/17</h1>
<p>;wip: dijkstra's algo</p>
<p>Dijkstra's algorithm requires that all arc costs be non-negative. Specifically, this is required to enforce to invariant that adding a node will strictly increase the cost.</p>
<h1 id="section-17">23/10/17</h1>
<p>Midterm will cover everything up to assignment 5.</p>
<p>Dijkstra's algorithm for the shortest <span class="math inline">s, t</span>-dipaths solves the problems for a given <span class="math inline">s</span> and any <span class="math inline">t \in N</span> - it gets the shortest path from one vertex to every other vertex. In other words, Dijkstra's algorithm produces a tree where <span class="math inline">s</span> is the root, and every path starting from <span class="math inline">s</span> is the shortest possible path.</p>
<p>A tree <span class="math inline">T</span> is a <strong>rooted tree at <span class="math inline">s</span></strong> if the unique <span class="math inline">s, t</span>-path in <span class="math inline">T</span> is a directed <span class="math inline">s, t</span>-path for all nodes <span class="math inline">t \in T</span>. Dijkstra's algorithm starting at <span class="math inline">s</span> always finds a tree rooted at <span class="math inline">s</span>.</p>
<p>If <span class="math inline">v_0, \ldots, v_k</span> is the shortest <span class="math inline">v_0, v_k</span>-dipath, then <span class="math inline">v_0, \ldots, v_i</span> is the shortest <span class="math inline">v_0, v_i</span>-dipath for any <span class="math inline">0 \le i \le k</span>. In other words, any prefix of a shortest path between two vertices is itself also a shortest path (assuming no negative cycles). Proof:</p>
<blockquote>
<p>Suppose <span class="math inline">P = v_0, \ldots, v_i</span> is not the shortest <span class="math inline">v_0, \ldots, v_i</span> is not the shortest <span class="math inline">v_0, v_i</span>-path for some <span class="math inline">i</span>. Let <span class="math inline">i</span> be the largest possible such that <span class="math inline">P</span> doesn't intersect <span class="math inline">v_i, \ldots, v_k</span>.<br />
Then there exists another <span class="math inline">v_0, v_i</span>-path <span class="math inline">P&#39;</span> with lower cost.<br />
If <span class="math inline">P&#39;</span> doesn't include any of <span class="math inline">v_{i + 1}, \ldots, v_k</span>, then <span class="math inline">P&#39;, v_{i + 1}, \ldots, v_k</span> is a <span class="math inline">v_0, v_k</span>-path with smaller cost - a contradiction.</p>
</blockquote>
<h2 id="bellman-ford-algorithm">Bellman-Ford algorithm</h2>
<p>This algorithm works even if there are negative costs, though we still can't have negative cycles (the algorithm will detect those, however).</p>
<p>Essentially, we start with an infeasible potential, and then repeatedly check for arcs that violate feasibility (arcs <span class="math inline">u, v</span> such that <span class="math inline">\overline w_{uv} &lt; 0</span>) and fix that by changing some potentials.</p>
<p>Bellman-Ford algorithm:</p>
<ol type="1">
<li>Initialize variables:
<ul>
<li><span class="math inline">s</span> is an arbitrary start node.</li>
<li><span class="math inline">y</span> is the potential, which starts off possibly infeasible. We define this as <span class="math inline">y_s = 0</span> and <span class="math inline">y_v = \infty</span> for any <span class="math inline">v \ne s</span>.</li>
<li><span class="math inline">P(v)</span> is the predecessor function for any node <span class="math inline">v</span>, initially undefined for any node.</li>
<li><span class="math inline">i = 0</span> is the counter.</li>
</ul></li>
<li>While <span class="math inline">i &lt; \abs{N}</span> and <span class="math inline">y</span> is not a feasible potential:
<ol type="1">
<li>Increment <span class="math inline">i</span>.</li>
<li>For all <span class="math inline">uv \in A</span>, if <span class="math inline">\overline w_{uv} &lt; 0</span>, then change <span class="math inline">y_v = y_u + w_{uv}</span> and set <span class="math inline">P(v) = u</span>.</li>
</ol></li>
<li>If the loop terminated without finding a feasible potential, the graph must have a negative cycle. Otherwise, we have a feasible potential and this gives us the shortest paths.</li>
</ol>
<div class="status-banner" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; text-align: center;">
    <div style="display: inline-block; padding: 0.8em 2em 0.5em 2em; background: black; color: white; font-size: 2em;">
        Rendering <svg xmlns="http://www.w3.org/2000/svg" height="1.4em" viewbox="0 0 1200 500" style="vertical-align: text-bottom"><title>LaTeX logo</title><g transform="matrix(45 0 0 45 40 40)" fill="white"><path d="M5.5 4.4C5.5 4.4 5.2 4.4 5.2 4.4 5.1 5.4 5 6.7 3.2 6.7 3.2 6.7 2.4 6.7 2.4 6.7 1.9 6.7 1.9 6.6 1.9 6.3 1.9 6.3 1.9 1 1.9 1 1.9 0.6 1.9 0.5 2.9 0.5 2.9 0.5 3.2 0.5 3.2 0.5 3.2 0.5 3.2 0.2 3.2 0.2 2.8 0.2 1.9 0.2 1.5 0.2 1.1 0.2 0.3 0.2 0 0.2 0 0.2 0 0.5 0 0.5 0 0.5 0.2 0.5 0.2 0.5 1 0.5 1 0.6 1 0.9 1 0.9 1 6.2 1 6.2 1 6.6 1 6.7 0.2 6.7 0.2 6.7 0 6.7 0 6.7 0 6.7 0 7 0 7 0 7 5.2 7 5.2 7 5.2 7 5.5 4.4 5.5 4.4z"/><path d="M5.3 0.2C5.3 0 5.2 0 5.1 0 5 0 4.9 0 4.9 0.2 4.9 0.2 3.3 4.2 3.3 4.2 3.2 4.4 3.1 4.7 2.5 4.7 2.5 4.7 2.5 5 2.5 5 2.5 5 4 5 4 5 4 5 4 4.7 4 4.7 3.7 4.7 3.5 4.6 3.5 4.4 3.5 4.3 3.5 4.3 3.6 4.2 3.6 4.2 3.9 3.4 3.9 3.4 3.9 3.4 5.9 3.4 5.9 3.4 5.9 3.4 6.3 4.4 6.3 4.4 6.3 4.4 6.3 4.5 6.3 4.5 6.3 4.7 5.9 4.7 5.8 4.7 5.8 4.7 5.8 5 5.8 5 5.8 5 7.7 5 7.7 5 7.7 5 7.7 4.7 7.7 4.7 7.7 4.7 7.6 4.7 7.6 4.7 7.1 4.7 7.1 4.7 7 4.5 7 4.5 5.3 0.2 5.3 0.2zM4.9 0.9C4.9 0.9 5.8 3.1 5.8 3.1 5.8 3.1 4 3.1 4 3.1 4 3.1 4.9 0.9 4.9 0.9z"/><path d="M13.3 0.2C13.3 0.2 7.2 0.2 7.2 0.2 7.2 0.2 7 2.5 7 2.5 7 2.5 7.3 2.5 7.3 2.5 7.4 0.9 7.6 0.5 9.1 0.5 9.3 0.5 9.5 0.5 9.6 0.6 9.8 0.6 9.8 0.7 9.8 0.9 9.8 0.9 9.8 6.2 9.8 6.2 9.8 6.5 9.8 6.7 8.8 6.7 8.8 6.7 8.4 6.7 8.4 6.7 8.4 6.7 8.4 7 8.4 7 8.8 6.9 9.8 6.9 10.3 6.9 10.7 6.9 11.7 6.9 12.2 7 12.2 7 12.2 6.7 12.2 6.7 12.2 6.7 11.8 6.7 11.8 6.7 10.7 6.7 10.7 6.5 10.7 6.2 10.7 6.2 10.7 0.9 10.7 0.9 10.7 0.7 10.7 0.6 10.9 0.6 11 0.5 11.3 0.5 11.5 0.5 13 0.5 13.1 0.9 13.2 2.5 13.2 2.5 13.5 2.5 13.5 2.5 13.5 2.5 13.3 0.2 13.3 0.2z"/><path d="M18.7 6.7C18.7 6.7 18.4 6.7 18.4 6.7 18.2 8.2 17.9 8.9 16.2 8.9 16.2 8.9 14.9 8.9 14.9 8.9 14.4 8.9 14.4 8.8 14.4 8.5 14.4 8.5 14.4 5.9 14.4 5.9 14.4 5.9 15.3 5.9 15.3 5.9 16.3 5.9 16.4 6.2 16.4 7 16.4 7 16.6 7 16.6 7 16.6 7 16.6 4.4 16.6 4.4 16.6 4.4 16.4 4.4 16.4 4.4 16.4 5.2 16.3 5.5 15.3 5.5 15.3 5.5 14.4 5.5 14.4 5.5 14.4 5.5 14.4 3.2 14.4 3.2 14.4 2.8 14.4 2.8 14.9 2.8 14.9 2.8 16.2 2.8 16.2 2.8 17.7 2.8 18 3.3 18.1 4.7 18.1 4.7 18.4 4.7 18.4 4.7 18.4 4.7 18.1 2.5 18.1 2.5 18.1 2.5 12.5 2.5 12.5 2.5 12.5 2.5 12.5 2.8 12.5 2.8 12.5 2.8 12.7 2.8 12.7 2.8 13.5 2.8 13.5 2.9 13.5 3.2 13.5 3.2 13.5 8.4 13.5 8.4 13.5 8.8 13.5 8.9 12.7 8.9 12.7 8.9 12.5 8.9 12.5 8.9 12.5 8.9 12.5 9.2 12.5 9.2 12.5 9.2 18.2 9.2 18.2 9.2 18.2 9.2 18.7 6.7 18.7 6.7z"/><path d="M21.7 3.1C21.7 3.1 23 1.1 23 1.1 23.3 0.8 23.6 0.5 24.5 0.5 24.5 0.5 24.5 0.2 24.5 0.2 24.5 0.2 22.1 0.2 22.1 0.2 22.1 0.2 22.1 0.5 22.1 0.5 22.5 0.5 22.7 0.7 22.7 0.9 22.7 1 22.7 1.1 22.6 1.2 22.6 1.2 21.5 2.8 21.5 2.8 21.5 2.8 20.2 0.9 20.2 0.9 20.2 0.9 20.1 0.8 20.1 0.8 20.1 0.7 20.4 0.5 20.8 0.5 20.8 0.5 20.8 0.2 20.8 0.2 20.4 0.2 19.7 0.2 19.3 0.2 19 0.2 18.4 0.2 18 0.2 18 0.2 18 0.5 18 0.5 18 0.5 18.2 0.5 18.2 0.5 18.8 0.5 19 0.5 19.2 0.8 19.2 0.8 21 3.6 21 3.6 21 3.6 19.4 6 19.4 6 19.2 6.2 18.9 6.7 17.9 6.7 17.9 6.7 17.9 7 17.9 7 17.9 7 20.3 7 20.3 7 20.3 7 20.3 6.7 20.3 6.7 19.8 6.7 19.7 6.4 19.7 6.2 19.7 6.1 19.7 6.1 19.8 6 19.8 6 21.2 3.9 21.2 3.9 21.2 3.9 22.8 6.3 22.8 6.3 22.8 6.3 22.8 6.3 22.8 6.4 22.8 6.5 22.6 6.7 22.2 6.7 22.2 6.7 22.2 7 22.2 7 22.5 6.9 23.2 6.9 23.6 6.9 24 6.9 24.5 7 24.9 7 24.9 7 24.9 6.7 24.9 6.7 24.9 6.7 24.7 6.7 24.7 6.7 24.2 6.7 24 6.6 23.8 6.3 23.8 6.3 21.7 3.1 21.7 3.1z"/></g></svg> math...
    </div>
</div>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2017 Anthony Zhang.
</div>
</body>
</html>
